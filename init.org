#+TITLE: Emacs Literate Configuration
#+AUTHOR: Tristan de Cacqueray
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes
#+PROPERTY: header-args:emacs-lisp :comments link

* About
This is my current configuration for Emacs. I have been using both Vim
and Emacs for a long time... Vim used to be better because it is light
and fast, but this is no longer relevant for me. I prefer Emacs because
magit provides an efficient git workflow.

For the best experience, I would recommend to build an Emacs configuration
one option at a time and avoid distribution such as Spacemacs.

This configuration is vastly inspired by [[https://github.com/dakra/dmacs][dmacs]] and the [[https://github.com/caisah/emacs.dz][emacs.dz awesome list]].
Also from [[https://git.sr.ht/~zge/emacs.d]]

** Installation
This config doesn't use ~package.el~ as package management but
[[https://emacsmirror.net/manual/borg/][borg]] which uses git submodules.
After first cloning this repository you have to call ~make bootstrap-borg~
to download the `borg` library and the you can execute ~make bootstrap~
to tangle this file and initialize all packages.
After that you can just call ~make~ to tangle and rebuild the packages
each time you make a change or ~make build-init~ if you only made
changes to this file.

* Emacs Initialization
We want to use lexical scoping
#+BEGIN_SRC emacs-lisp :comments nil
;;; init.el --- user-init-file                    -*- lexical-binding: t -*-
#+END_SRC

Show a few messages with timestamps to get a better overview of how fast
Emacs is loading certain packages.
#+BEGIN_SRC emacs-lisp
(defvar before-user-init-time (current-time)
  "Value of `current-time' when Emacs begins loading `user-init-file'.")
(message "Loading Emacs...done (%.3fs)"
  (float-time (time-subtract before-user-init-time before-init-time)))
#+END_SRC

Show required package that takes more than 1ms to load.
Remove ":tangle no" to enable.
TODO: enable this only when interactive and remove tangle no switch
#+BEGIN_SRC emacs-lisp
(defadvice require (around my-require activate)
  (let ((start (current-time))
        res delta)
    (setq res ad-do-it)
    (setq delta (float-time (time-since start)))
    (when (> delta 0.001)
      (message "Required %s: %s sec" (ad-get-arg 0) delta))
    res))
#+END_SRC

We're going to increase the gc-cons-threshold to a very high number to decrease
the load and compile time.  We'll lower this value significantly after
initialization has completed. We don't want to keep this value too high or it
will result in long GC pauses during normal usage.
#+BEGIN_SRC emacs-lisp
(setq gc-cons-threshold (* 256 1024 1024))
#+END_SRC

Temporarily disable file name handlers as it's not needed on initialization
#+BEGIN_SRC emacs-lisp
(defvar file-name-handler-alist-old file-name-handler-alist)
(setq file-name-handler-alist nil)
#+END_SRC

Increase max number of log messages
#+BEGIN_SRC emacs-lisp
(setq message-log-max 16384)
#+END_SRC

** Set some early UI settings
Disable Tool and Menubar
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

Set fringe to a small value so we don't have big borders in exwm
but can still see our diff-hl colors in the fringe
#+BEGIN_SRC emacs-lisp
(fringe-mode '(4 . 4))
#+END_SRC

Disable startup screen and startup echo area message and select the
scratch buffer by default
#+BEGIN_SRC emacs-lisp
(setq-default
   inhibit-startup-message t
   inhibit-startup-buffer-menu t
   inhibit-startup-screen t
   inhibit-startup-echo-area-message t
   initial-buffer-choice t
   initial-scratch-message nil)
#+END_SRC

Ensure latest version of a file is loaded
#+BEGIN_SRC emacs-lisp
(setq-default load-prefer-newer t)
#+END_SRC

** Package Management
*** Org config tangle
There is no ~emacs.el~ in this repo. It will automatically be created for you
from this file (~emacs.org~) when you run ~make build-init~.

Don't forget to call ~make~ every time you edit this file.
If this annoys you, you could simply add an ~after-save-hook~ that
calls ~make~ every time you save this file.

*** Package Settings
We use borg for package management and disable ~package.el~.

Since Emacs 27.1 we have to disable package.el in the early init file.
#+BEGIN_SRC emacs-lisp :tangle early-init.el
(setq package-enable-at-startup nil)
#+END_SRC

But still leave it here so it's also disabled on machines that don't
have the latest Emacs from master installed.
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
#+END_SRC

*** Borg
Initialize borg package management.
#+BEGIN_SRC emacs-lisp
(setq user-init-file (or load-file-name buffer-file-name))
(setq user-emacs-directory (file-name-directory user-init-file))
(add-to-list 'load-path (expand-file-name "lib/borg" user-emacs-directory))
(setq borg-rewrite-urls-alist
  '(("git@github.com:" . "https://github.com/")
    ("git@gitlab.com:" . "https://gitlab.com/")))
(require 'borg)
(borg-initialize)
#+END_SRC

Assimilate new packages using the ~borg-clone~ and ~borg-build~ or simply
the ~borg-assimilate~ command.
Update version by changing git submodule and running make.

Borg uses ssh by default, if you don't have a git account, run these
commands:
#+BEGIN_SRC bash :tangle no
git config --global url.https://github.com/.insteadOf git@github.com:
git config --global url.https://gitlab.com/.insteadOf git@gitlab.com:
git config --global url.https://code.orgmode.org/.insteadOf git@code.orgmode.org:
#+END_SRC

Submodule gets dirty because of lisp compilation and autoload list, add
these to the ~/.config/git/ignore file:
#+BEGIN_SRC bash :tangle no
*.elc
*-autoloads.el
#+END_SRC

*** Use-Package
The use-package macro allows you to isolate package configuration in your
.emacs file in a way that is both performance-oriented and, well, tidy.
#+BEGIN_SRC emacs-lisp
  (require 'use-package)
  (setq use-package-verbose t)

  ;; For the :bind keyword
  (use-package bind-key)

  ;; For the :diminish keyword, to replace mode names in modeline
  (use-package diminish)
#+END_SRC

*** Epkg
This package provides access to a local copy of the Emacsmirror package
database. It provides low-level functions for querying the database and
a package.el-like user interface for browsing the available packages.

Describe package using the ~epkg-describe-package~ command.

#+BEGIN_SRC emacs-lisp
(use-package epkg
  :defer t
  :init (setq epkg-repository
              (expand-file-name "var/epkgs/" user-emacs-directory)))

;; Using auto-compile guarantee that Emacs never loads outdated byte code files.
(use-package auto-compile
  :demand t
  :config
  (auto-compile-on-load-mode)
  (auto-compile-on-save-mode)
  (setq auto-compile-display-buffer               t)
  (setq auto-compile-mode-line-counter            t)
  (setq auto-compile-source-recreate-deletes-dest t)
  (setq auto-compile-toggle-deletes-nonlib-dest   t)
  (setq auto-compile-update-autoloads             t)
  (add-hook 'auto-compile-inhibit-compile-hook
            'auto-compile-inhibit-compile-detached-git-head))
#+END_SRC

* Solarized theme
Use the solarized dark theme without bolding or text scaling.
#+BEGIN_SRC emacs-lisp :comments nil
(use-package solarized-theme
  :defer t
  :bind (("C-+" . text-scale-increase)
         ("C--" . text-scale-decrease))
  :init
  (setq
   ;; Put underline below descent for better legibility.
   x-underline-at-descent-line t

   solarized-use-less-bold t

   ;; Don't use variable-pitch.
   solarized-use-variable-pitch nil

   ;; Don't use variable scale text.
   solarized-scale-org-headlines nil
   solarized-height-minus-1 1.0
   solarized-height-plus-1 1.0
   solarized-height-plus-2 1.0
   solarized-height-plus-3 1.0
   solarized-height-plus-4 1.0))
(load-theme 'solarized-dark t)
#+END_SRC

Use the Hack font.
#+BEGIN_SRC emacs-lisp :comments nil
(set-frame-font "Hack 9")
#+END_SRC

* Personal Information
Let's set some variables with basic user information.
Remove ":tangle no" to use inlined identity such as:
#+BEGIN_SRC emacs-lisp :tangle no
(setq user-full-name "Tristan Cacqueray"
      user-mail-address "tristanc@wombatt.eu"
      mime-edit-pgp-signers '("453BBC30D147881719C9A8E97A457A788345FE5C")
      calendar-latitude 37.5
      calendar-longitude 126.9
      calendar-location-name "Seoul, KR")
#+END_SRC

Or copy and edit the identity in a separated file:
#+BEGIN_SRC emacs-lisp
(load "~/.emacs.d/identity.el" t)
#+END_SRC

* Change Emacs default config
Set default settings, use "C-h v" to desribe the variable
#+BEGIN_SRC emacs-lisp :comments nil
;; TODO: break this in logical group
(setq-default
  ;; Select in primary selection, not clipboard
  select-enable-primary t
  select-enable-clipboard nil

  ;; Always follow symlinks
  vc-follow-symlinks t

  ;; Do not fill sentence ending with two space in paragraphs.el
  sentence-end-double-space nil

  ;; Scroll one line when cursor moves out of the window
  scroll-step 1
  ;; Scroll up to 100 lines to bring back the cursor on screen
  scroll-conservatively 100

  ;; Do not flash on bell
  visible-bell nil
  ring-bell-function 'ignore

  ;; Auto wrap after some columns
  fill-column 120

  ;; Confirm closing emacs
  confirm-kill-emacs 'y-or-n-p

  ;; Display filepath in window title
  frame-title-format (list '(buffer-file-name "%f" (dired-directory dired-directory "%b")))

  ;; Don't use tabs to indent, use 4 spaces instead
  indent-tabs-mode nil
  tab-width 4
  ;; smart tab behavior - indent or complete
  tab-always-indent 'complete

  ;; Ensure file ends with newline
  require-final-newline t

  ;; Paste at cursor position, not at mouse pointer
  mouse-yank-at-point t

  ;; Activate character folding in searches i.e. searching for 'e' matches 'Ã©'
  search-default-mode 'char-fold-to-regexp

  ;; Only split vertically on very tall screens
  split-height-threshold 110

  ;; don't "ping Germany" when typing test.de<TAB>
  ffap-machine-p-known 'reject

  ;; Always just use left-to-right text
  ;; This makes Emacs a bit faster for very long lines
  bidi-display-reordering nil

  ;; Put authinfo.gpg first so new secrets will be stored there by default
  auth-sources '("~/.authinfo.gpg" "~/.authinfo" "~/.netrc")

  ;; Increase the 'Limit on number of Lisp variable bindings.
  ;; mu4e seems to need more sometimes and it can be safely increased.
  max-specpdl-size 2048

  ;; Do not save backup in projects, keep them in home
  auto-save-file-name-transforms `((".*" "~/.emacs-saves/" t))
  backup-directory-alist `((".*" . ,"~/.emacs-saves/"))
  )
#+END_SRC

Set some global key binding (TODO: move this to another section?)
#+BEGIN_SRC emacs-lisp :comments nil
;; C-x k : don't ask for buffer name
(global-set-key (kbd "C-x k") 'kill-this-buffer)

;; Ignore korean layout switch
(global-set-key (kbd "<Hangul_Hanja>") 'ignore)

;; Indent selection by one tab length
(global-set-key (kbd "C->") 'indent-rigidly-right-to-tab-stop)
(global-set-key (kbd "C-<") 'indent-rigidly-left-to-tab-stop)

;; Don't quit Emacs on C-x C-c
(when (daemonp)
  (global-set-key (kbd "C-x C-c") 'kill-buffer-and-window))
#+END_SRC

Enable some global hook (TODO: move this to another section?)
#+BEGIN_SRC emacs-lisp :comments nil
;; Delete trailing white spaces on save
(add-hook 'before-save-hook 'delete-trailing-whitespace)

;; Mark scripts executable
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

Enable some global mode (TODO: move this to another section?)
#+BEGIN_SRC emacs-lisp :comments nil
;; Syntax highligth all the things
(global-font-lock-mode t)

;; Automatically insert closing parenthesis, brackets, ... TODO: move to prog
(electric-pair-mode 1)

;; Blink!
(blink-cursor-mode 1)

;; Enable frame navigation using Shift+arrow TODO: fix org-mode conflict
(windmove-default-keybindings)

;; Show line and column number
(line-number-mode 1)
(column-number-mode 1)

(if (display-graphic-p)
  (progn
  ;; Highlight the current line
  (global-hl-line-mode 1)

  ;; Highlight stuff
  (global-hi-lock-mode 1)))

;; Replace some name with pretty symbols like lambda
(global-prettify-symbols-mode t)

;; Do not truncate lines by default
(toggle-truncate-lines -1)
;; Default to utf-8 unix encoding
(prefer-coding-system 'utf-8-unix)
;; Accept 'UTF-8' (uppercase) as a valid encoding in the coding header
(define-coding-system-alias 'UTF-8 'utf-8)

;; Force Emacs to use English timestamps
(setq system-time-locale "C")
#+END_SRC

** Extras
*** Disable lockfiles
	#+BEGIN_SRC emacs-lisp
	  (setq create-lockfiles nil)
	#+END_SRC

	Lockfiles appear when a file is opened and confuses some tools. I
	trust /myself/ to not come into a situation where lockfiles are
	needed, and have therefore disabled them.

*** Frame resizing
	#+BEGIN_SRC emacs-lisp
	  (setq frame-resize-pixelwise t)
	#+END_SRC

	When using graphical Emacs, this option enables more flexible
	resizing of the entire frame.
*** Window resizing
	#+BEGIN_SRC emacs-lisp
	  (setq window-combination-resize t)
	#+END_SRC

	This option make Emacs split windows in a more sane and visually
	pleasing manner, ie. proportionally.


* Configure Emacs builtin packages
Improved default settings
** Customs
Store custom variable set from the GUI to a separate file.
The file content shall be assimilated in the main configuration if relevant.
#+BEGIN_SRC emacs-lisp
(use-package custom
  :no-require t
  :config
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
    (load custom-file)))
#+END_SRC

** Mode-line-format: remove modes
Minor and major modes clutter the status bar, I'd rather use C-h m to get the list when needed.
Note that this makes diminish useless.
#+BEGIN_SRC emacs-lisp
(setq-default mode-line-format
  '("%e"
   mode-line-front-space mode-line-mule-info mode-line-client mode-line-modified
   mode-line-auto-compile mode-line-remote
   mode-line-frame-identification mode-line-buffer-identification "   "
   mode-line-position evil-mode-line-tag mode-line-misc-info mode-line-end-spaces
))
#+END_SRC

** Dash: A modern list library for Emacs
#+BEGIN_SRC emacs-lisp :comments nil
(use-package dash
  :config
  ;; Syntax highlighting
  (dash-enable-font-lock))
#+END_SRC

** Paren: Show matching parenthesis, brackets, ...
#+BEGIN_SRC emacs-lisp
(use-package paren
  :config
  (setq show-paren-delay 0.0)
  (show-paren-mode))
#+END_SRC
To extend the default Emacs appearance, matching parentheses are
highlighted, which is helpful when working with Lisp code.

** Man: Man page documentation.
#+BEGIN_SRC emacs-lisp :comments nil
(use-package man
  :defer t
  :config (setq Man-width 80))
#+END_SRC

** Recentf: Keep a list of recent files.
#+BEGIN_SRC emacs-lisp :comments nil
(use-package recentf
  :demand t
  :config
  (add-to-list 'recentf-exclude "^/\\(?:ssh\\|su\\|sudo\\)?:")
  (setq-default
    recentf-max-saved-items 256))
#+END_SRC

** Auto-revert: Revert buffer when file changes on disk
#+BEGIN_SRC emacs-lisp
(use-package autorevert
  :defer 1
  ;; Auto revert file on opening
  :hook (find-file . auto-revert-mode)
  :config
  ;; We only really need auto revert for git files
  ;; and we use magits `magit-auto-revert-mode' for that
  ;;; revert buffers automatically when underlying files are changed externally
  (global-auto-revert-mode nil)

  ;; Turn off auto revert messages
  ;; (setq auto-revert-verbose nil)
)
#+END_SRC

** Epa: EasyPG Assistant
#+BEGIN_SRC emacs-lisp
(use-package epa
  :defer t
  :config
  ;; Always replace encrypted text with plain text version
  (setq epa-replace-original-text t))
(use-package epa-file
  :config
  (epa-file-enable))
(use-package epg
  :defer t
  :config
  ;; Let Emacs query the passphrase through the minibuffer
  (setq epg-pinentry-mode 'loopback))
#+END_SRC

** Saveplace: Remember your location in a file
#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :unless noninteractive
  :config
  (setq save-place-file "~/.emacs.d/saveplace")
  (setq-default save-place t)
  (save-place-mode))
#+END_SRC

** Savehist: Keep track of minibuffer history
#+BEGIN_SRC emacs-lisp
(use-package savehist
  :unless noninteractive
  ;; :defer 1
  :config
  ;; (setq savehist-additional-variables '(compile-command regexp-search-ring))
  (savehist-mode 1))
#+END_SRC

** Ansi-color
#+BEGIN_SRC emacs-lisp
(use-package ansi-color
  :commands ansi-color-display)
#+END_SRC

** Compile: Run compiler
#+BEGIN_SRC emacs-lisp
(use-package compile
  :bind (:map compilation-mode-map
         ("C-c -" . compilation-add-separator)
         ("-" . compilation-add-separator)
         :map comint-mode-map
         ("C-c -" . compilation-add-separator))
  :config
  (defun compilation-add-separator ()
    "Insert separator in read-only buffer."
    (interactive)
    (let ((inhibit-read-only t))
      (insert "\n------------------------\n\n")))

  ;; Always save before compiling
  (setq compilation-ask-about-save nil)
  ;; Just kill old compile processes before starting the new one
  (setq compilation-always-kill t)
  ;; Scroll with the compilation output
  ;; Set to 'first-error to stop scrolling on first error
  (setq compilation-scroll-output t))
#+END_SRC

** Comint: Interact with programs
Comint mode is a package that defines a general command-interpreter-in-a-buffer.
#+BEGIN_SRC emacs-lisp
  ;; https://oleksandrmanzyuk.wordpress.com/2011/10/23/a-persistent-command-history-in-emacs/
  ;; this implementation use buffer-name instead of process name, so that different shell history doesn't minx
  ;; todo: investigate using projectile info to further group history?
  (defun turn-on-comint-history ()
    (let ((process (get-buffer-process (current-buffer))))
      (when process
        (setq comint-input-ring-file-name
              (expand-file-name (format "~/.emacs.d/inferior-%s-history"
                      (replace-regexp-in-string "[*/]" "-" (buffer-name (current-buffer))))))
        (message "buffer history will be:" comint-input-ring-file-name)
        (comint-read-input-ring)
        (set-process-sentinel process #'comint-write-history-on-exit))))
  (defun comint-write-history-on-exit (process event)
    (comint-write-input-ring)
    (let ((buf (process-buffer process)))
      (when (buffer-live-p buf)
        (with-current-buffer buf
          (insert (format "\nProcess %s %s" process event))))))
  (use-package comint
    :defer t
    :config
    (defun mapc-buffers (fn)
      (mapc (lambda (buffer)
              (with-current-buffer buffer
                (funcall fn)))
            (buffer-list)))

    (defun comint-write-input-ring-all-buffers ()
      (mapc-buffers 'comint-write-input-ring))

    (add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
    ;; Increase comint buffer size.
    (setq comint-buffer-maximum-size 32768))
#+END_SRC

** Subword: CamelCase aware editing operations
#+BEGIN_SRC emacs-lisp
(use-package subword
  :diminish
  :hook
  ((python-mode yaml-mode go-mode clojure-mode cider-repl-mode) . subword-mode))
#+END_SRC

** Shr: Simple html renderer
#+BEGIN_SRC emacs-lisp
(use-package shr
  :defer t
  :config
  (setq shr-width 80)
  (setq shr-external-browser 'eww-browse-url)
  (setq shr-color-visible-luminance-min 80))
#+END_SRC

** Makefile
#+BEGIN_SRC emacs-lisp
(use-package make-mode
  ;; Files like `Makefile.docker' are also gnu make
  :mode (("Makefile" . makefile-gmake-mode)))
#+END_SRC

** Calendar
#+BEGIN_SRC emacs-lisp
(use-package calendar
  :hook (calendar-today-visible . calendar-mark-today)
  :config
  ;; Highlight public holidays
  (setq calendar-holiday-marker t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(message "Loading early birds...done (%.3fs)"
         (float-time (time-subtract (current-time) before-user-init-time)))
#+END_SRC

* Editor extra packages
** God-mode: simulate vim mode by prefixing any key by Control
This mode enable navigation without using the Control key
#+BEGIN_SRC emacs-lisp
  (use-package god-mode
    ;; disable for now because of bad interaction with magit
    :disabled t
    :init
    (defun update-cursor ()
      (setq cursor-type (if (or god-local-mode buffer-read-only)
                            'bar
                          'box)))
    (add-hook 'god-mode-enabled-hook 'update-cursor)
    (add-hook 'god-mode-disabled-hook 'update-cursor)
    :config
    (global-set-key (kbd "<escape>") 'god-mode-all)
    ;;(setq god-exempt-major-modes nil)
    ;;(setq god-exempt-predicates nil)
    ;;(bind-keys :map launcher-map
    ;;           ("g" . god-local-mode))
    (bind-keys :map god-local-mode-map
              ;; ("z" . repeat)
              ;; ("." . repeat)
               ("i" . god-local-mode))
    ;;(add-to-list 'god-exempt-major-modes 'org-agenda-mode)
    (add-to-list 'god-exempt-major-modes 'notmuch-hello)
    (add-to-list 'god-exempt-major-modes 'notmuch-show)
    (add-to-list 'god-exempt-major-modes 'notmuch-search)
    (add-to-list 'god-exempt-major-modes 'magit-status)

    ;; Navigate window layout using zp zn zb zf
    (global-unset-key (kbd "C-z"))
    (global-set-key (kbd "C-z C-p") 'windmove-up)
    (global-set-key (kbd "C-z C-n") 'windmove-down)
    (global-set-key (kbd "C-z C-b") 'windmove-left)
    (global-set-key (kbd "C-z C-f") 'windmove-right)

    ;; Split screen using x1 x2...
    ;;(global-set-key (kbd "C-x C-1") 'delete-other-windows)
    ;;(global-set-key (kbd "C-x C-2") 'split-window-below)
    ;;(global-set-key (kbd "C-x C-3") 'split-window-right)
    ;;(global-set-key (kbd "C-x C-0") 'delete-window)
    ;;(global-set-key (kbd "C-x C-g") 'magit-status)
    ;;(global-set-key (kbd "C-x C-k") 'kill-this-buffer)
    ;;(global-set-key (kbd "C-x C-o") 'other-window)
    )
  (use-package god-mode-isearch
    :config
    (define-key isearch-mode-map (kbd "<escape>") 'god-mode-isearch-activate)
    (define-key god-mode-isearch-map (kbd "<escape>") 'god-mode-isearch-disable))
#+END_SRC

** UI
*** Nyan cat: Buffer position with a cat
#+BEGIN_SRC emacs-lisp
(use-package nyan-mode
  :config
  (nyan-mode))
#+END_SRC

*** Eldoc: Display help
#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :hook (prog-mode . eldoc-mode)
  :config
  (global-eldoc-mode))
#+END_SRC

*** Hl-todo: Highlight and navigate TODO keywords
#+BEGIN_SRC emacs-lisp
(use-package hl-todo
  :disabled t
  :defer 2
  :config (global-hl-todo-mode))
#+END_SRC

*** Volatile highlights: visual feedback on some operations like yank,kill,undo
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :disabled t
  :defer 10
  :config (volatile-highlights-mode t))
#+END_SRC

*** beacon: Highlight current line/cursor when switching frames
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :defer 5
  :diminish
  :config
  ;; don't blink in notmuch-search, it's both slow and ugly
  (add-to-list 'beacon-dont-blink-major-modes #'notmuch-search-mode)
  (beacon-mode 1))
#+END_SRC

*** which-key: Display available keybindings in popup
which-key displays the key bindings following your currently entered incomplete
command (a prefix) in a popup. For example, after enabling the minor mode if you
enter C-x and wait for the default of 1 second the minibuffer will expand with
all of the available key bindings that follow C-x (or as many as space allows
given your settings). This includes prefixes like C-x 8 which are shown in a
different face
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish
    :config
    (setq which-key-separator " "
          which-key-prefix-prefix "+")
    :config (which-key-mode 1))
#+END_SRC

*** which-func: Show the name of the current function definition in the modeline
#+BEGIN_SRC emacs-lisp
(use-package which-func
  :defer 5
  :disabled t
  :config (which-function-mode 1))
#+END_SRC

*** Nicer buffer name for buffers with same name
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :defer 5
  :config
  (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-separator "/")
  ; (setq uniquify-buffer-name-style 'forward)
  ; (setq mode-line-identification "%f")
  ; (setq sml/shorten-directory nil)
  ; (setq sml/shorten-modes nil)
)
#+END_SRC

*** Highlight indentions
#+BEGIN_SRC emacs-lisp
(use-package highlight-indent-guides
  :diminish
  :disabled t
  :hook ((sass-mode yaml-mode) . highlight-indent-guides-mode))
#+END_SRC

*** Highlight trailing whitespaces and tabs
#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :diminish
  :hook (prog-mode . whitespace-mode)
  :config
  (setq whitespace-style
    (quote
    (face trailing tabs lines empty space-after-tab space-before-tab tab-mark)))

  ;; highlight lines with more than `fill-column' characters
  ;; TODO: that may be too pedantic, check how to enable only for some mode
  (setq whitespace-line-column nil))
#+END_SRC

*** rainbow-delimiters: Different color for each paranthesis level
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :hook ((emacs-lisp-mode lisp-mode hy-mode) . rainbow-delimiters-mode))
#+END_SRC

** Editor
*** Undo-Tree: undo history done right
#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :diminish
  :config
  ;; (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)
  (global-undo-tree-mode))
#+END_SRC

*** Automatically remove trailing whitespace (only if I put them there)
TODO pick this or the delete-trailing-whitespace save-hook
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :diminish
  :hook ((text-mode prog-mode) . ws-butler-mode)
  :config (setq ws-butler-keep-whitespace-before-point nil))
#+END_SRC

*** Simple clip: manually manage clipboard
Use C-<insert> and Shift-<insert> to copy and paste the clipboard.
Use mouse and middle-mouse to copy and paste the primary clipboard.
#+BEGIN_SRC emacs-lisp
(use-package simpleclip
  :config
  (simpleclip-mode 1))
#+END_SRC

*** Cycle outline and code visibility
These are minor modes to selectively hide/show code and comment blocks
#+BEGIN_SRC emacs-lisp
(use-package hideshow
  :diminish
  :disabled t
  :hook (prog-mode  . hs-minor-mode))

(use-package outline
  :diminish
  :hook ((prog-mode message-mode markdown-mode) . outline-minor-mode))

(use-package bicycle
  :diminish
  :disabled t
  :after outline
  :bind (:map outline-minor-mode-map
         ([C-tab] . bicycle-cycle)
         ([backtab] . bicycle-cycle-global)))
#+END_SRC

*** Smartparens: smarter parenthesis mode
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :config
  :disabled t
  (require 'smartparens-config)
  (smartparens-global-mode))
#+END_SRC

*** Company: Auto completion
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish
  :config
  ;;(setq company-idle-delay 0.1)
  ;;(setq company-tooltip-limit 10)
  ;;(setq company-minimum-prefix-length 2)
  (global-set-key (kbd "M-SPC") 'company-complete)
  (global-company-mode 1)

  (use-package company-quickhelp
    :config (company-quickhelp-mode 1)))

;;(use-package all-the-icons)
;;(use-package company-box
;;  :hook (company-mode . company-box-mode))
#+END_SRC

*** Helpful: A better help buffer
Helpful is a replacement for ~*help*~ buffers that provides much more contextual information.
#+BEGIN_SRC emacs-lisp
(use-package helpful
  :bind (("C-h f" . helpful-function)
         ("C-h v" . helpful-variable)
         ("C-h s" . helpful-symbol)
         ("C-h k" . helpful-key)))
#+END_SRC

*** keyfreq: record command frequencies
TODO: write a script to show daily/weekly/monthly stats.
#+BEGIN_SRC emacs-lisp
(use-package keyfreq
  :config
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)

  ;; Archive keyfreq daily for statistic purpose...
  (defun my/archivekeyfreq ()
    "Function to archive keyfreq daily"
    (unless (file-exists-p "~/.emacs-freqs")
        (make-directory "~/.emacs-freqs"))
    (let ((daily-file (concat "~/.emacs-freqs/dump-" (format-time-string "%F") ".json")))
      (unless (file-exists-p daily-file)
        (keyfreq-json daily-file)))
    (message "%s: ran archivekeyfreq" (current-time-string )))
  ;; Archive on start
  (my/archivekeyfreq)
  ;; And every hour
  (run-at-time "05:00" (* 3600 24) #'my/archivekeyfreq))
  ;; (list-timers)
#+END_SRC
*** anzu: visual replace feedback
#+BEGIN_SRC emacs-lisp :comments nil
(use-package anzu
  :config
  (global-anzu-mode +1))
#+END_SRC

*** perspective: workspace
#+BEGIN_SRC emacs-lisp :comments nil
(use-package perspective
  :config
  (persp-mode))
#+END_SRC

** Evil: vim mode and bindings
#+BEGIN_SRC emacs-lisp :comments nil
  (use-package evil
    :disabled t
    :init
    ;; (setq evil-want-integration t)
    ;; (setq evil-want-keybinding nil)
    :hook (after-init . evil-mode)
    :config
    (progn
      ;; stop messing with clipboard please
      (evil-define-operator evil-destroy (beg end type register yank-handler)
        (evil-delete beg end type ?_ yank-handler))
      (evil-define-operator evil-destroy-replace (beg end type register yank-handler)
        (evil-destroy beg end type register yank-handler)
        (evil-paste-before 1 register))

      ;; Make evil undo only one char at a time
      (advice-add 'undo-auto--last-boundary-amalgamating-number
                  :override #'ignore)
      (setq evil-want-fine-undo t)

      ;; TODO: check what is this :)
      (add-hook 'with-editor-mode-hook 'evil-insert-state)))
#+END_SRC

** Ivy
*** Smex: fuzzy matching for M-x
#+BEGIN_SRC emacs-lisp
(use-package smex
  :defer t)
#+END_SRC

*** Counsel
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :diminish
    :bind (("C-x C-f" . counsel-find-file)
           ("M-y"     . counsel-yank-pop)
           ("M-i"     . counsel-imenu)
           ("M-x"     . counsel-M-x))
    :config
    ;; Hide pyc and elc files by default from `counsel-find-file'
    (setq counsel-find-file-ignore-regexp "\\.\\(pyc\\|elc\\)\\'")
    ;; Add action to open file literally
    ;; This makes opening of files with minified js or sql dumps possible.
    (ivy-add-actions 'counsel-find-file
                     `(("l" find-file-literally "Open literally")))
    (counsel-mode 1))
#+END_SRC

*** Swiper: Search with ivy
Replace evil search function "/" by swiper
#+BEGIN_SRC emacs-lisp
(use-package swiper
  :bind (("M-s" . swiper))
  :config
  ;; (define-key evil-normal-state-map "/" 'swiper)
)
#+END_SRC

*** Ivy: Incremental completYon
#+BEGIN_SRC emacs-lisp
;; colir is a color blending library
(use-package colir)
(use-package ivy
  :diminish
  :config
  (setq
    ;; Always case insensitive search
    ivy-case-fold-search-default (quote always)
    ;; Extend searching to bookmarks and recentf
    ivy-use-virtual-buffers t
    ;; does not count candidates
    ivy-count-format ""
    ;; only show 18 candidates
    ivy-height 18
    ;; no regexp by default
    ivy-initial-inputs-alist nil
    ;; Don't quit ivy when pressing backspace on already empty input
    ivy-on-del-error-function nil
    ;; allow out of order inputs
    ivy-re-builders-alist '((t   . ivy--regex-ignore-order))
    ;; Show full path for virtual buffers
    ivy-virtual-abbreviate 'full
    ;; Press C-p when you're on the first candidate to select your input
    ivy-use-selectable-prompt t)
  (ivy-mode 1))
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp :comments nil
  (use-package magit
    :commands (magit-status)
    :bind ("C-x g"   . magit-status)
    :config
    (setq magit-push-always-verify nil)
    (magit-add-section-hook 'magit-status-sections-hook
                            'magit-insert-modules
                            'magit-insert-stashes
                            'append))
#+END_SRC
#+BEGIN_SRC emacs-lisp :comments nil
(use-package diff-hl
  :config
  (setq diff-hl-draw-borders nil)
  (global-diff-hl-mode)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh t))
#+END_SRC

** sbuffer: Like ibuffer, but using magit-section
#+BEGIN_SRC emacs-lisp :comments nil
(use-package sbuffer
  :after magit)
#+END_SRC
** Project Management
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer t
  :bind-keymap (("s-p"   . projectile-command-map)
                ("C-c p" . projectile-command-map))
  :init
  ;; Allow all file-local values for project root
  (put 'projectile-project-root 'safe-local-variable 'stringp)
  :config
  ;; cache projectile project files
  ;; projectile-find-files will be much faster for large projects.
  ;; C-u C-c p f to clear cache before search.
  (setq-default
    ;; Start magit-status when switching project
    projectile-switch-project-action (quote magit-status)

    ;; Don't show "Projectile" as liter when not in a project
    projectile-mode-line-prefix ""
    ;; Cache management
    projectile-file-exists-local-cache-expire 30
    projectile-enable-caching t
    ;; Use ivy
    projectile-completion-system 'ivy)
  (projectile-mode))
#+END_SRC

Also use direnv to customize per project environment
(From https://www.adelbertc.com/posts/2020-01-06-emacs-rls-nix.html):
#+BEGIN_SRC emacs-lisp
(use-package direnv
  :init
  (add-hook 'prog-mode-hook #'direnv-update-environment)
  :config
  (direnv-mode))
#+END_SRC

** Dired
#+BEGIN_SRC emacs-lisp
(use-package dired
  :bind (("C-x d" . dired)
         :map dired-mode-map
         ("M-RET" . emms-play-dired)
         ("e" . dired-ediff-files)
         ("C-c C-e" . dired-toggle-read-only))
  :config
  ;; always delete and copy recursively
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
)
(use-package dired-rainbow
  :after dired
  :config
  (dired-rainbow-define html "#4e9a06" ("htm" "html" "xhtml"))
  (dired-rainbow-define xml "#b4fa70" ("xml" "xsd" "xsl" "xslt" "wsdl"))

  (dired-rainbow-define document font-lock-function-name-face ("doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub"))
  (dired-rainbow-define excel "#3465a4" ("xlsx"))
  ;; FIXME: my-dired-media-files-extensions not defined?
  ;;(dired-rainbow-define media "#ce5c00" my-dired-media-files-extensions)
  (dired-rainbow-define image "#ff4b4b" ("jpg" "png" "jpeg" "gif"))

  (dired-rainbow-define log "#c17d11" ("log"))
  (dired-rainbow-define sourcefile "#fcaf3e" ("py" "c" "cc" "cpp" "h" "java" "pl" "rb" "R"
                                              "php" "go" "rust" "js" "ts" "hs"))

  (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
  (dired-rainbow-define compressed "#ad7fa8" ("zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar"
                                              "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
  (dired-rainbow-define packaged "#e6a8df" ("deb" "rpm"))
  (dired-rainbow-define encrypted "LightBlue" ("gpg" "pgp"))

  (dired-rainbow-define-chmod executable-unix "Green" "-.*x.*"))

#+END_SRC

** Nov: epub reader
#+BEGIN_SRC emacs-lisp :comments nil
(use-package nov-mode
  :defer t
  :mode "\\.epub\\'")
#+END_SRC
* Org mode
** General Setup
Workflow is vastly inspired by http://doc.norang.ca/org-mode.html
#+BEGIN_SRC emacs-lisp :comments nil
    (use-package org
      :config
      (setq-default
        ;; Tell org where are the files
        org-directory "~/org/"

        ;; Display image inline
        org-startup-with-inline-images t

        ;; Ensure shift arrows execute org commands, e.g. change todo state.
        org-support-shift-select nil

        ;; Insead of "..." show "â¦" when there's hidden folded content
        ;; Some characters to choose from: â¦, â¤µ, â¼, â´, â¬, â¤·, and â±
        org-ellipsis "â¤µ"

        ;; Show headings up to level 2 by default when opening an org files
        org-startup-folded 'content

        ;; Simple TODO sequence
        org-todo-keywords (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                                  (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)")))
        org-todo-keyword-faces (quote (("TODO" :foreground "red" :weight bold)
                                       ("NEXT" :foreground "blue" :weight bold)
                                       ("DONE" :foreground "forest green" :weight bold)
                                       ("WAITING" :foreground "orange" :weight bold)
                                       ("HOLD" :foreground "magenta" :weight bold)
                                       ("CANCELLED" :foreground "forest green" :weight bold)))
        ;; Change state using C-c C-t
        org-use-fast-todo-selection t
        ;; But don't bother with notes when using shift arrows
        org-treat-S-cursor-todo-selection-as-state-change nil
        ;; Auto tag task
        org-todo-state-tags-triggers (quote (("CANCELLED" ("CANCELLED" . t))
                                             ("WAITING" ("WAITING" . t))
                                             ("HOLD" ("WAITING") ("HOLD" . t))
                                             (done ("WAITING") ("HOLD"))
                                             ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                                             ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                                             ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))

        ;; TODO what is this?
        org-startup-indented t
        org-src-fontify-natively t
        org-startup-indented t
        org-log-done t
        org-clock-persist-query-save t
        org-adapt-indentation nil
        org-log-done 'time

        ;; Show inline images by default
        org-startup-with-inline-images t

        ;; Only show one star, though this is overridden by org-bullets
        org-hide-leading-stars t

        ;; Mail link description format, %c if from or to when sent by me
        org-email-link-description-format "Email %c (%d): %s"
        )

        ;; Enable windmove-default-keybindings in org-mode
        (add-hook 'org-shiftup-final-hook 'windmove-up)
        (add-hook 'org-shiftleft-final-hook 'windmove-left)
        (add-hook 'org-shiftdown-final-hook 'windmove-down)
        (add-hook 'org-shiftright-final-hook 'windmove-right)


      ;; Custom links
      ;; http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html
      (defvar yt-iframe-format
      ;; You may want to change your width and height.
      (concat "<iframe width=\"560\""
              " height=\"315\""
              " src=\"https://www.youtube.com/embed/%s\""
              " frameborder=\"0\""
              " allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\""
              " allowfullscreen></iframe>"))

    (org-add-link-type
     "yt"
     (lambda (handle)
       (browse-url
        (concat "https://www.youtube.com/embed/"
                handle)))
     (lambda (path desc backend)
       (cl-case backend
         (md (format yt-iframe-format
                       path (or desc "")))
         (html (format yt-iframe-format
                       path (or desc "")))
         (latex (format "\href{%s}{%s}"
                        path (or desc "video"))))))


      )
#+END_SRC

** Org Packages
*** Capture: quickly capture informations from anywhere
#+BEGIN_SRC emacs-lisp
  (use-package org-capture
    :bind ("C-c c" . org-capture)
    :demand
    :config
    (setq-default
     org-default-notes-file "~/org/refile.org.gpg"
     org-capture-templates '(
                             ("t" "todo" entry (file "~/org/refile.org.gpg")
                              "* TODO %? %a\n%U\n")
                             ("m" "Meeting" entry (file "agenda.org.gpg")
                              "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
                             ("j" "Journal" entry (file+datetree "journal.org.gpg")
                              "* %?\nEntered on %U\n  %i\n  %a")
                             )
     ;; Use any org-agendas file as refile target, only first level
     org-refile-targets '((org-agenda-files :maxlevel . 1))
     ;; Use full outline paths for refile targets
     org-refile-use-outline-path t
     ;; Targets complete directly
     org-outline-path-complete-in-steps nil
     ;; Don't refile in gcal file
     org-refile-target-verify-function
      (lambda () (not (or (string= (file-name-nondirectory (buffer-file-name)) "gcal.org")
                    (string= (file-name-nondirectory (buffer-file-name)) "prodchain.org")))))
    )
#+END_SRC
*** Agenda: show agenda with scheduled todos
#+BEGIN_SRC emacs-lisp
(use-package org-agenda
  :bind ("<f12>"   . org-agenda)
  :config
  (setq-default
    ;; Start agenda at today
    org-agenda-start-on-weekday nil
    ;; Look for agenda item in every org files
    org-agenda-files '("~/org")
    ;; Match encrypted files too
    org-agenda-file-regexp "\\`[^.].*\\.org\\(.gpg\\)?\\'"
    ;; Do not dim blocked tasks
    org-agenda-dim-blocked-tasks nil
    ;; Compact the block agenda view
    org-agenda-compact-blocks t
    ;; Customize view
    org-agenda-custom-commands
      (quote (("N" "Notes" tags "NOTE"
               ((org-agenda-overriding-header "Notes")
                (org-tags-match-list-sublevels t)))
              ("h" "Habits" tags-todo "STYLE=\"habit\""
               ((org-agenda-overriding-header "Habits")
                (org-agenda-sorting-strategy
                 '(todo-state-down effort-up category-keep))))
              (" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Tasks to Refile")
                       (org-tags-match-list-sublevels nil)))))))))
#+END_SRC
*** Bullet: replace star with utf-8 bullets
#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
)
#+END_SRC
*** Export: export settings
#+BEGIN_SRC emacs-lisp
(use-package ox
  :config
  (setq-default
    ;; Use html5 as org export and use new tags
    org-html-doctype "html5"
    org-html-html5-fancy t
    ;; Don't add html footer to export
    org-html-postamble nil
    ;; Don't export ^ or _ as super/subscripts
    org-export-with-sub-superscripts nil
  )
)
;; Github markdown
(use-package ox-gfm
  :after ox)

;; reStructuredText
(use-package ox-rst
  :after ox)

;; Hugo blog posts
(use-package ox-hugo
  :after ox)
(use-package ox-hugo-auto-export
  :after ox-hugo)
#+END_SRC
*** Set a dark background for source blocks
#+BEGIN_SRC emacs-lisp
  (require 'color)
  (if (display-graphic-p)
      (set-face-attribute 'org-block nil :background
                          (color-darken-name
                           (face-attribute 'default :background) 2)))

#+END_SRC
*** Habit: special todo items for repeated task
Whatâs really useful about habits is that they are displayed along with a
consistency graph, to show how consistent youâve been at getting that
task done in the past.
#+BEGIN_SRC emacs-lisp
(use-package org-habit
  :after org)
#+END_SRC

*** Expiry: Automatically add a CREATED property when inserting a new headline
#+BEGIN_SRC emacs-lisp
(use-package org-expiry
  ;; TODO: check why load-path is needed here
  :load-path "~/.emacs.d/lib/org/contrib/lisp/"
  :after org
  :config
  (setq org-expiry-inactive-timestamps t)
  (org-expiry-insinuate))
#+END_SRC

*** Notmuch: link mail from org mode
#+BEGIN_SRC emacs-lisp
(use-package ol-notmuch
  :demand t
  :after (:any org notmuch))
#+END_SRC
** Zettel mode
#+BEGIN_SRC emacs-lisp
(use-package zettel-mode
  :config
  (setq neuron-zettelkasten (expand-file-name "~/git/perso/zettelkasten")))
#+END_SRC

* Term
** Shell
#+BEGIN_SRC emacs-lisp :comments nil
(use-package shell
  :config
  (add-hook 'shell-mode-hook 'turn-on-comint-history))
#+END_SRC
** Eshell
#+BEGIN_SRC emacs-lisp :comments nil
(use-package eshell
  :config
  (setq-default
    eshell-hist-ignoredups t
))
#+END_SRC
** Ansi terminal

From https://www.emacswiki.org/emacs/AnsiTermHints
#+BEGIN_SRC emacs-lisp :comments nil
  (defun term/shell (program &optional new-buffer-name)
    "Start a terminal-emulator in a new buffer.

      With a prefix argument, it prompts the user for the shell
      executable.

      If there is already existing buffer with the same name, switch to
      that buffer, otherwise it creates new buffer.

      Like `shell', it loads `~/.emacs_SHELLNAME' if exists, or
      `~/.emacs.d/init_SHELLNAME.sh'.

      The shell file name (sans directories) is used to make a symbol
      name such as `explicit-bash-args'.  If that symbol is a variable,
      its value is used as a list of arguments when invoking the
      shell."
    (interactive (let ((default-prog (or explicit-shell-file-name
                                         (getenv "ESHELL")
                                         shell-file-name
                                         (getenv "SHELL")
                                         "/bin/sh")))
                   (list (if (or (null default-prog)
                                 current-prefix-arg)
                             (read-from-minibuffer "Run program: " default-prog)
                           default-prog))))

    ;; Pick the name of the new buffer.
    (setq term-ansi-buffer-name
          (if new-buffer-name
              new-buffer-name
            (if term-ansi-buffer-base-name
                (if (eq term-ansi-buffer-base-name t)
                    (file-name-nondirectory program)
                  term-ansi-buffer-base-name)
              "shell/term")))

    (setq term-ansi-buffer-name (concat "*" term-ansi-buffer-name "*"))

    ;; In order to have more than one term active at a time
    ;; I'd like to have the term names have the *term-ansi-term<?>* form,
    ;; for now they have the *term-ansi-term*<?> form but we'll see...
    (when current-prefix-arg
      (setq term-ansi-buffer-name
            (generate-new-buffer-name term-ansi-buffer-name)))

    (let* ((name (file-name-nondirectory program))
           (startfile (concat "~/.emacs_" name))
           (xargs-name (intern-soft (concat "explicit-" name "-args"))))
      (unless (file-exists-p startfile)
        (setq startfile (concat user-emacs-directory "init_" name ".sh")))

      (setq term-ansi-buffer-name
            (apply 'term-ansi-make-term term-ansi-buffer-name program
                   (if (file-exists-p startfile) startfile)
                   (if (and xargs-name (boundp xargs-name))
                       ;; `term' does need readline support.
                       (remove "--noediting" (symbol-value xargs-name))
                     '("-i")))))

    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-line-mode)                      ; (term-char-mode) if you want



    (setq term-buffer-maximum-size 65535)

    ;; I wanna have find-file on C-x C-f -mm
    ;; your mileage may definitely vary, maybe it's better to put this in your
    ;; .emacs ...

    (term-set-escape-char ?\C-x)
    (switch-to-buffer term-ansi-buffer-name))


  (defun open-localhost ()
    (interactive)
    (ansi-term "bash" "localhost"))

  ;; Use this for remote so I can specify command line arguments
  (defun remote-term (new-buffer-name cmd &rest switches)
    (setq term-ansi-buffer-name (concat "*" new-buffer-name "*"))
    (setq term-ansi-buffer-name (generate-new-buffer-name term-ansi-buffer-name))
    (setq term-ansi-buffer-name (apply 'make-term term-ansi-buffer-name cmd nil switches))
    (set-buffer term-ansi-buffer-name)
    (term-mode)
    (term-char-mode)
    (term-set-escape-char ?\C-x)
    (switch-to-buffer term-ansi-buffer-name))

  (defun open-cmdev2 ()
    (interactive)
    (remote-term "cmdev2" "ssh" "kreg@cmdev2.dsa.int"))
#+END_SRC

** Tramp
#+BEGIN_SRC emacs-lisp :comments nil
;; (use-package tramp-loaddefs)
(use-package tramp
  :defer t)
#+END_SRC
* Mail
This is my setup to process mails. As a disclaimer I'm posting here as other
may find it useful, but be advised it's fine tuned for my personal needs.
In particular, this setup features:

- Different specialized tools for each task instead of an all-in-one solution.
  I find usual client like thunderbird not good enough at syncing and archiving.
  Tools like dovecot sieve and mbsync are much more efficient.
- Tag based index instead of folder hierarchy. This enables differents views such as
  by sender or by topic, while keeping the actual mail file in a single place.
- Local archive for fast search and org-mode references. This is very powerful combined
  with org-capture as it enables todos with direct reference to a mail view.
- New threads gets an *unseen* tag that I triage as *watched* or *ignored*.
  This is a key feature to keep a low noise ratio for busy lists.
  I use a custom python script to apply tags based on a complex rules.
- Handle large volume.

** Command lines
*** mbsync
Mbsync fetchs all the mails from imaps to the local inbox. This configuration doesn't
expunge and leave the mail untouched on the remote server.
#+BEGIN_SRC txt :tangle ~/mail-conf/mbsyncrc.sample
Expunge None
Create Both

MaildirStore local
Path ~/Maildir/
Inbox ~/Maildir/inbox/
Trash Trash

IMAPStore home
User tristanC
Pass secret
Host imap.perso

Channel home
Master :home:
Slave :local:
Expunge None
Sync Pull

IMAPStore work
User tdecacqu
Pass secret
Host imap.corp
AuthMechs LOGIN
SSLType IMAPS
SSLVersions TLSv1.2

Channel work
Master :work:
Slave :local:
Expunge None
Sync Pull

Channel work-memo
Master :work:"memo-list"
Slave :local:
Expunge None
Sync Pull
#+END_SRC

*** sieve-filter
Dovecot sieve filter just move the mails from the mbsync inbox to date
based folders to store the mails archived by default.
#+BEGIN_SRC txt :tangle ~/mail-conf/filter.sieve
require ["fileinto", "date", "variables", "mailbox", "regex"];

# Default variables
set "box" "unknown";
set "month" "00";
set "year" "0000";

# Extract Date: header
if date :matches "date" "month" "*" { set "month" "${1}"; }
if date :matches "date" "year"  "*" { set "year"  "${1}"; }

# Notifications
if anyof (exists "X-Gerrit-Change-Id",
          exists "X-Jenkins-Job",
          exists "X-Cron-Env",
          exists "X-GitHub-Sender",
          exists "X-Launchpad-Bug",
          exists "X-Bugzilla-Product",
          exists "X-JIRA-FingerPrint",
          exists "X-StoryBoard-Subscription-Type") {
    set "box" "pulse/${year}.${month}";
}

# Feeds
elsif exists "X-RSS-ID" {
    set "box" "feeds/${year}.${month}";
}

# Lists
elsif exists "List-Id" {
    set "box" "lists/${year}.${month}";
}

# Big mails
elsif size :over 1M {
    set "box" "parcel/${year}.${month}";
}

# Archive the rest
else {
    set "box" "letterbox/${year}.${month}";
}

fileinto :create "${box}";
#+END_SRC

To run sieve-filter manually, dovecot needs this configuration:
#+BEGIN_SRC txt :tangle ~/mail-conf/dovecot.conf
postmaster_address = root@localhost
mail_location = maildir:~/Maildir/:INBOX=~/Maildir/inbox:LAYOUT=fs

plugin {
    sieve_global =
}
#+END_SRC

*** notmuch-config
"notmuch new" indexes every new files and adds the new tag. The synchronize_flags
option let it mark the filename with the draft and unread tag when needed.
#+BEGIN_SRC txt :tangle ~/mail-conf/notmuch-config.sample
[database]
path=/home/Maildir

[user]
name=Tristan
primary_mail=tristanC@wombatt.eu

[new]
tags=new;
ignore=

[search]
exclude_tags=deleted;spam;

[maildir]
synchronize_flags=true

[crypto]
gpg_path=gpg2
#+END_SRC

*** notmuch-tag
Here is my custom script to process the new mails, inspired by [[https://notmuchmail.org/initial_tagging/][this doc]]:
#+BEGIN_SRC python :tangle ~/mail-conf/notmuch-tag.py :tangle-mode (identity #o755)
#!/bin/env python3
import email
import time
import notmuch
import argparse
import logging
import re

parser = argparse.ArgumentParser()
parser.add_argument("--debug", action="store_true")
parser.add_argument("--dry", action="store_true")
parser.add_argument("--query", default="tag:new")
args = parser.parse_args()
logging.basicConfig(format='%(asctime)s %(levelname)s - %(message)s',
    level=logging.DEBUG if args.debug else logging.INFO)
log = logging.getLogger()

start_time = time.time()
#+END_SRC

First load some custom list:
#+BEGIN_SRC python :tangle ~/mail-conf/notmuch-tag.py
def readlines(name):
    """Read file, remove comment and return lowercase line lists"""
    return filter(lambda x: x != '' and x[0] != '#',
        map(str.strip,
            map(str.lower,
                open("mail-conf/taglist-%s.txt" % name).readlines())))

def load_list(name):
    """Return un-ordered list"""
    return set(readlines(name))

def load_taglist(name):
    """Return ordered list of (id, [tags, ])"""
    return list(
        map(lambda x: (x.split()[0], x.split(None, 1)[1].split()),
            readlines(name)))

# My mail addresses
me = load_list("me")
# List of special people
boss = load_list("boss")
vip = load_list("vip")
team = load_list("team")
vmt = load_list("vmt")
bots = load_list("bots")
spam = load_list("spam")
# Packages I care about
pkgs = load_list("packages")
# List-id to tags mapping
lists = load_taglist("lists")
#+END_SRC

Utility function to load message body:
#+BEGIN_SRC python :tangle ~/mail-conf/notmuch-tag.py
def get_body(msg):
    message = email.message_from_binary_file(open(msg.get_filename(), "rb"))
    try:
        if message.is_multipart():
            # Load each parts
            body = "".join(map(lambda x: x.as_string(), message.get_payload()))
        else:
            body = message.get_payload()
    except (KeyError, UnicodeEncodeError, LookupError) as e:
        log.exception("[W]: couldn't decode %s from %s (%s): %s",
            msg.get_message_id(), msg.get_header("from"),
            msg.get_header("subject"), e)
        body = ""
    return body.lower()
#+END_SRC

Main message processing function:
#+BEGIN_SRC python :tangle ~/mail-conf/notmuch-tag.py
def process(msg):
    tags = set()
    mail_to = msg.get_header("To").lower()
    mail_cc = msg.get_header("Cc").lower()
    mail_from = msg.get_header("From").lower()
    mail_sender = msg.get_header("Sender").lower()
    subject = msg.get_header("Subject").lower()
    gh_sender = msg.get_header("X-GitHub-Sender")
    thread_id = msg.get_thread_id()
    body = get_body(msg)

    # This process remove the new tag
    tags.add('-new')

    # Check mail_to
    if [True for s in me if s in mail_to or s in mail_cc]:
        tags.add("to-me")

    # Check mail_from
    if [True for s in me if s in mail_from]:
        tags.add("sent")
        tags.add("inbox")
        tags.add("-quoted")
        tags.add("-unread")
    elif [True for s in boss if s in mail_from]:
        tags.add("boss")
    elif [True for s in vip if s in mail_from]:
        tags.add("vip")
    elif [True for s in team if s in mail_from]:
        tags.add("team")
    elif [True for s in vmt if s in mail_from]:
        # Only add vmt if content relate to vmt
        if [True for c in ("security", "vmt", "ossa", "ossg")
                 if (c in subject or c in body)]:
            tags.add("vmt")
    elif [True for s in spam if s in mail_from]:
        tags.add("spam")
        tags.add("-to-me")
    elif "calendar-notification" in mail_from:
        tags.add("calendar")
        tags.add("-to-me")
        if subject == "you have no events scheduled today.":
            tags.add("-unread")
    elif "no-reply@taiga.io" in mail_from:
        tags.add("bug")
        tags.add("-to-me")
        if "comment: " not in body:
            tags.add("-unread")

    # Check message headers
    if msg.get_header("X-Gerrit-Change-Id"):
        tags.add("code")
        tags.add("-list")
        tags.add("-to-me")
        if " ci (code review)" in mail_from or \
           "zuul (code review)" in mail_from or \
           "zuul osp sf (code review)" in mail_from or \
           "jenkins (code review)" in mail_from:
            # Mark CI results as read
            tags.add("-unread")
        elif msg.get_header("X-Gerrit-MessageType") == "comment":
            if re.search("patch set [0-9]+: .*\n\n--\nto view", body) or \
               "\nrecheck\n" in body:
                tags.add("-unread")
        elif msg.get_header("X-Message-Type") != "newchange":
            tags.add("-unread")
    elif msg.get_header("X-pagure"):
        if "zuul <pagure@pagure.io>" in mail_from or \
           "zuul ci bot" in mail_from or \
           "zuul bot <pagure" in mail_from:
            # Mark CI results as read
            tags.add("-unread")
        tags.add("code")
        tags.add("-list")
        tags.add("-to-me")
    elif gh_sender:
        tags.add("code")
        tags.add("-list")
        tags.add("-to-me")
        if gh_sender in bots:
            # Mark CI results as read
            tags.add("-unread")
    elif msg.get_header("X-GitLab-Project"):
        tags.add("code")
        tags.add("-list")
        tags.add("-to-me")
    # bug reports
    elif (msg.get_header("X-Launchpad-Bug") or
          "@bugs.launchpad.net" in mail_from):
        tags.add("bug")
        tags.add("-to-me")
    elif (msg.get_header("X-StoryBoard-Subscription-Type") or
          "@storyboard.openstack.org" in mail_from):
        tags.add("bug")
        tags.add("-to-me")
    elif msg.get_header("X-Bugzilla-Product"):
        tags.add("bug")
        tags.add("-to-me")
        if msg.get_header("X-Bugzilla-Comment") == "no":
            tags.add("-unread")
    elif msg.get_header("X-RSS-ID"):
        tags.add("feed")
    # vmt stuff
    if msg.get_header("X-Launchpad-Bug-Security-Vulnerability") == "yes" or \
       "OSSA" in subject or "embargo-notice" in subject:
        tags.add("vmt")
    if msg.get_header("X-Launchpad-Bug-Private") == "yes":
        tags.add("watched")
    # monitoring
    if msg.get_header("X-Cron-Env") or \
       "root@softwarefactory-project.io" in mail_from or \
       "monit@" in mail_from or \
       "prometheus@" in mail_from:
        tags.add("-to-me")
        tags.add("-list")
        tags.add("monit")
    # mailing lists
    list_id = msg.get_header("List-Id").lower()
    if list_id and "-list" not in tags:
        tags.add('list')
        tags.add("-to-me")
        found = False
        for list_name, list_tags in lists:
            if list_name in list_id:
                for tag in list_tags:
                    tags.add(tag)
                found = True
                break
        if not found:
            tags.add("untagged-list")

        if "security.lists.openwall.com" in list_id and \
           [True for pkg in pkgs if pkg in body]:
            # Watch packages mentioned on oss-sec
            tags.add("watched")

    if "calendar-notification" in mail_sender:
        tags.add("-to-me")
        tags.add("calendar")

    if "-to-me" in tags:
        tags.add("-inbox")

    # Remove tags to be removed
    for untag in [tag[1:] for tag in tags if tag[0] == "-"]:
        if untag in tags:
            tags.remove(untag)

    # Check for quote
    ignore_quote_set = set(("bug", "code", "sent", "to-me", "calendar"))
    if not tags.intersection(ignore_quote_set) and (
        "tdecacqu" in body or ("tristan" in body and "cacqueray" in body) or
        "@tristan" in body):
       qquoted = notmuch.Query(db, 'thread:%s and tag:replied' % thread_id)
       if len(list(qquoted.search_messages())) == 0:
           tags.add('quoted')

    # Update watched tag
    qwatched = notmuch.Query(db, 'thread:%s and tag:watched' % thread_id)
    if len(list(qwatched.search_messages())) > 0:
        tags.add('watched')

    # Add unseen tag for new threads
    if "-unread" not in tags and "watched" not in tags and \
       tags.intersection(set(("list", "code", "bug", "vmt"))):
        qunseen = notmuch.Query(db, 'thread:%s and ('
            'tag:inbox or tag:unseen or tag:watched or tag:ignored or '
            'tag:archive or tag:deleted)' % thread_id)
        if len(list(qunseen.search_messages())) == 0:
            tags.add('unseen')

    if 'to-me' in tags and '-to-me' not in tags:
        tags.add('inbox')

    log.debug("[%s]: from:%s subject:%s",
        ", ".join(sorted(filter(lambda x: x[0] != "-", tags))),
        mail_from, subject[:40])
    return tags
#+END_SRC

Process new messages and apply tags:
#+BEGIN_SRC python :tangle ~/mail-conf/notmuch-tag.py
db = notmuch.Database(mode=notmuch.Database.MODE.READ_WRITE)
idx = 0
try:
    for msg in notmuch.Query(db, args.query).search_messages():
        if not args.dry:
            msg.freeze()
        tags = process(msg)
        if args.dry:
            continue

        # Apply tags
        for tag in tags:
            if tag[0] == '+':
                msg.add_tag(tag[1:])
            elif tag[0] == '-':
                sync = False
                if tag == "-unread":
                    # Propagate unread removal to the maildir filename
                    sync = True
                msg.remove_tag(tag[1:], sync_maildir_flags=sync)
            else:
                msg.add_tag(tag)

        # Check for aliens, in case the process method didn't find any tags
        if set(msg.get_tags()).issubset(set((
                "attachment", "encrypted", "new", "signed", "unread"))):
            # No tags was added, mark it to remember
            # the process() method needs to be improved
            msg.add_tag("alien")
        msg.thaw()
        idx += 1
        if args.debug and idx % 100:
            print("%d\r" % idx, end='')
except KeyboardInterrupt:
    pass
log.info("Tagged %d messages in %1.2f seconds", idx, time.time() - start_time)
exit(0)
#+END_SRC

*** msmtp
msmtp takes care of processing the sendmail queue:
#+BEGIN_SRC txt :tangle ~/mail-conf/msmtprc.sample
defaults
auth            on
tls             on
tls_trust_file  /etc/ssl/certs/ca-bundle.crt
logfile         ~/logs/msmtp.log

account         default
host            smtp.corp
port            587
from            tdecacqu@

account         perso
host            smtp.perso
port            25
from            tristanC@
#+END_SRC

*** sync script
Finally, this script wraps all the above:
#+BEGIN_SRC bash :tangle ~/mail-conf/sync :tangle-mode (identity #o755)
#!/bin/bash -e
echo "$(date): begin"
export LD_LIBRARY_PATH=${HOME}/.emacs.d/lib/notmuch/lib/
export PYTHONPATH=${HOME}/.emacs.d/lib/notmuch/bindings/python/
export NOTMUCH=${HOME}/.emacs.d/lib/notmuch/notmuch
# Send the queue
~/conf/msmtp-listqueue.sh
~/conf/msmtp-runqueue.sh
# Sync mail
mbsync -Va 2>&1 | tee logs/mbsync.log | grep "^master:"
# Filter the inbox
sieve-filter -W -e -c .dovecot.conf -v  .filter.sieve inbox &> logs/sieve.log
# Index new mails
$NOTMUCH new 2>&1 | grep -v "Ignoring non-mail file"
# Tag new mails
./conf/notmuch-tag.py --debug | tee logs/tag.log
# Send notification
NEW=$($NOTMUCH count tag:inbox and tag:unread)
if [ $NEW -gt 0 ]; then
    notify-send "$NEW unread mails" --icon=mail-message-new
fi
# Backup
if [ $[ $(date "+%s") - $(stat -c %Y backup/status || echo 0) ] -gt 86400 ]; then
  echo "$(date): daily index backup"
  $NOTMUCH dump | gzip -9 > backup/nm-dump-$(date "+%Y-%m-%d").gz && touch backup/status
fi
echo "$(date): done"
#+END_SRC

** Emacs configuration
I use notmuch-hello mode to browse, manage and compose mails:
#+BEGIN_SRC emacs-lisp :comments nil
(use-package notmuch
  :preface (setq-default notmuch-command "~/.emacs.d/lib/notmuch/notmuch")
  :bind (("C-x m" . notmuch-hello)
          (:map notmuch-show-mode-map
           ("r" . notmuch-show-reply-sender)
           ("R" . notmuch-show-reply)
           ("a" . my/toggle-archive-message)
           ("f" . my/toggle-flagged-message)
           ("N" . my/toggle-unread-message)
           ("*" . my/watch-message)
           ("k" . my/ignore-message))
          (:map notmuch-search-mode-map
           ("r" . notmuch-search-reply-to-thread)
           ("R" . notmuch-search-reply-to-thread-sender)
           ("a" . my/toggle-archive-thread)
           ("f" . my/toggle-flagged-thread)
           ("D" . my/trash-thread)
           ("N" . my/toggle-unread-thread)
           ("*" . my/watch-thread)
           ("k" . my/ignore-thread)))
  :config
  (defun my/trash-thread (&optional beg end)
    "delete a thread"
    (interactive)
    (notmuch-search-tag '("+deleted" "+ignored" "-inbox"))
    (next-line))

  (defun my/toggle-unread-thread (&optional beg end)
    "toggle thread unread"
    (interactive)
    (if (member "unread" (notmuch-search-get-tags))
        (notmuch-search-tag '("-unread"))
        (notmuch-search-tag '("+unread")))
    (next-line))

  (defun my/toggle-unread-message ()
    "toggle message unread"
    (interactive)
    (if (member "unread" (notmuch-show-get-tags))
        (notmuch-show-tag '("-unread"))
        (notmuch-show-tag '("+unread"))))

  (defun my/toggle-flagged-thread (&optional beg end)
    "toggle thread flagged"
    (interactive)
    (if (member "flagged" (notmuch-search-get-tags))
        (notmuch-search-tag '("-flagged"))
        (notmuch-search-tag '("+flagged"))))

  (defun my/toggle-flagged-message ()
    "toggle message flagged"
    (interactive)
    (if (member "flagged" (notmuch-show-get-tags))
        (notmuch-show-tag '("-flagged"))
        (notmuch-show-tag '("+flagged"))))

  (defun my/toggle-archive-thread (&optional beg end)
    "toggle thread archive"
    (interactive)
    (if (member "archive" (notmuch-search-get-tags))
        (notmuch-search-tag '("-archive" "+inbox"))
        (notmuch-search-tag '("+archive" "-inbox" "-unseen"))))

  (defun my/toggle-archive-message ()
    "toggle message archive"
    (interactive)
    (if (member "archive" (notmuch-show-get-tags))
        (notmuch-show-tag '("-archive" "+inbox"))
        (notmuch-show-tag '("+archive" "-inbox"))))

  (defun my/ignore-thread (&optional beg end)
    "Ignore a thread"
    (interactive)
    (notmuch-search-tag (list "-unseen" "-watched" "-inbox" "+ignored") beg end)
    (next-line))

  (defun my/ignore-message ()
    "Ignore a thread from the show mode"
    (interactive)
    (notmuch-show-tag-all (list "-unseen" "-watched"))
    (notmuch-show-tag (list "+ignored")))

  (defun my/watch-thread (&optional beg end)
    "Watch a thread"
    (interactive)
    (notmuch-search-tag (list "-unseen" "+watched" "-ignored") beg end)
    (next-line))

  (defun my/watch-message ()
    "Watch a thread from the show mode"
    (interactive)
    (notmuch-show-tag-all (list "-unseen" "-ignored"))
    (notmuch-show-tag (list "+watched")))

  (setq-default
    ;; do not load all the messages on search, needs:
    ;; https://notmuchmail.org/pipermail/notmuch/2019/027309.html
    notmuch-progressive-search t

    ;; drop the logo on the front page
    notmuch-show-logo nil

    ;; adjust hello sections
    notmuch-hello-sections (quote (
      notmuch-hello-insert-saved-searches
      notmuch-hello-insert-recent-searches
      notmuch-hello-insert-alltags
      notmuch-hello-insert-footer))

    ;; notmuch-search-oldest-first defines the sort order
    notmuch-search-oldest-first nil

    ;; do not prompt for sender
    notmuch-always-prompt-for-sender nil

    ;; send from user-mail-address by default
    message-sendmail-envelope-from nil
    mail-specify-envelope-from nil
    mail-envelope-from nil

    ;; notmuch-show-all-multipart/alternative-parts defines that notmuch should
    ;; not show all alternative parts of the mail; this is often just some junk
    ;; I'm not interested in.
    notmuch-show-all-multipart/alternative-parts nil

    mime-edit-pgp-encrypt-to-self t
    mml-secure-openpgp-encrypt-to-self t
    mml-secure-openpgp-sign-with-sender t

    notmuch-crypto-process-mime t

    ;; Send with msmtp
    message-send-mail-function 'message-send-mail-with-sendmail
    sendmail-program "/data/conf/msmtp-enqueue.sh"
    message-sendmail-f-is-evil nil

    ;; Get sending mail error
    mail-interactive t

    notmuch-message-headers '("To" "Cc" "Subject" "Date")

    ;; Keep a local copy of sent mail
    notmuch-fcc-dirs '((".*" . "Maildir/sent"))
    message-kill-buffer-on-exit t
    mail-user-agent 'message-user-agent
    notmuch-show-indent-messages-width 4
    notmuch-saved-searches '(
      (:name "alien"    :key "a" :query "tag:alien")
      (:name "inbox"    :key "i" :query "tag:inbox"
                           :count-query "tag:inbox and tag:unread")
      (:name "flagged"  :key "f" :query "tag:flagged"
                           :count-query "tag:flagged and tag:unread")
      (:name "sicp"     :key "S" :query "tag:sicp and not tag:ignored"
                           :count-query "tag:sicp and not tag:ignored and tag:unread")
      (:name "sec"      :key "s" :query "(tag:vmt or (tag:watched and tag:sec))"
                           :count-query "(tag:vmt or (tag:watched and tag:sec)) and tag:unread")
      (:name "monit"    :key "m" :query "tag:monit and not tag:ignored and tag:unread"
                           :count-query "tag:monit and not tag:ignored and tag:unread" :key "m")
      (:name "team"     :key "t" :query "tag:team and not (tag:code or tag:calendar)"
                           :count-query "tag:team and not (tag:code or tag:calendar) and tag:unread")
      (:name "code"     :key "c" :query "(tag:watched and (tag:code or tag:bug) and tag:unread)"
                           :count-query "(tag:watched and (tag:code or tag:bug)) and tag:unread")
      (:name "watched"  :key "w" :query "(tag:watched and not (tag:code or tag:bug))"
                           :count-query "(tag:watched and not (tag:code or tag:bug)) and tag:unread")
      (:name "new-code" :key "C" :query "tag:unseen and (tag:code or tag:bug)")
      (:name "unseen"   :key "u" :query "tag:unseen and not (tag:code or tag:bug)" :sort-order 'oldest-first)
      (:name "vip"      :key "v" :query "(tag:vip or tag:boss)"
                           :count-query "(tag:vip or tag:boss) and tag:unread")
      (:name "calendar" :key "g" :query "tag:calendar"
                           :count-query "tag:calendar and tag:unread")
      (:name "quoted"   :key "q" :query "tag:quoted"
                           :count-query "tag:quoted and tag:unread")
      (:name "feed"     :key "F" :query "tag:feed and not tag:ignored"
                           :count-query "tag:feed and not tag:ignored and tag:unread")
      (:name "weekly"   :key "W" :query "date:last_week..now and not tag:ignored"
                           :count-query "date:last_week..now and not tag:ignored tag:unread")
      (:name "drafts"   :key "d" :query "tag:draft")
      (:name "all mail"          :query "*"))))

(use-package message
  :config
  (setq
    ;; Set domain name for message-ID
    message-user-fqdn "fedora"

    ;; Cite reply author with a date
    message-citation-line-format "On %a, %b %d, %Y at %H:%M %N wrote:"
    message-citation-line-function 'message-insert-formatted-citation-line)

  ;; Auto sign mails (borrowed from https://emacs.stackexchange.com/questions/19867/set-the-pgp-signing-marker-to-the-top-of-the-new-message)
  (defun ck/sign-message ()
    "Add the #secure tag on top of the message"
    (interactive)
    (goto-char (point-min))
    (search-forward "--text follows this line--")
    (end-of-line)
    (insert "\n")
    (mml-secure-message-sign-pgpmime))
  (add-hook 'message-setup-hook 'ck/sign-message)


  ;; Encrypt mails by calling (mml-secure-message-encrypt-pgpmime)

  ;; Redefine message-unique-id to generate custom Message-ID without fsf@
  (defun message-unique-id ()
    ;; Don't use microseconds from (current-time), they may be unsupported.
    ;; Instead we use this randomly inited counter.
    (setq message-unique-id-char
      (% (1+ (or message-unique-id-char
          (logand (random most-positive-fixnum) (1- (lsh 1 20)))))
      ;; (current-time) returns 16-bit ints,
      ;; and 2^16*25 just fits into 4 digits i base 36.
      (* 25 25)))
    (let ((tm (current-time)))
      (concat
        (if (or (eq system-type 'ms-dos)
          ;; message-number-base36 doesn't handle bigints.
          (floatp (user-uid)))
        (let ((user (downcase (user-login-name))))
          (while (string-match "[^a-z0-9_]" user)
            (aset user (match-beginning 0) ?_))
            user)
        (message-number-base36 (user-uid) -1))
        (message-number-base36 (+ (car tm)
                                  (lsh (% message-unique-id-char 25) 16)) 4)
        (message-number-base36 (+ (nth 1 tm)
                                  (lsh (/ message-unique-id-char 25) 16)) 4)
     ;; Append a given name, because while the generated ID is unique
     ;; to this newsreader, other newsreaders might otherwise generate
     ;; the same ID via another algorithm.
     ".tristanC"))))

(use-package mml
  :config
  (progn
    ;; http://mbork.pl/2015-11-28_Fixing_mml-attach-file_using_advice
    (defun my:mml-attach-file--go-to-eob (orig-fun &rest args)
      "Go to the end of buffer before attaching files."
      (save-excursion
        (save-restriction
          (widen)
          (goto-char (point-max))
          (apply orig-fun args))))
    (advice-add 'mml-attach-file :around #'my:mml-attach-file--go-to-eob)

    ;; Remove old interface
    (defun mml-secure-sign ())
    (defun mml-secure-sign-pgp ())
    (defun mml-secure-sign-pgpauto ())
    (defun mml-secure-sign-pgpmime ())
    (defun mml-secure-sign-smime ())
    (defun mml-secure-encrypt ())
    (defun mml-secure-encrypt-pgp ())
    (defun mml-secure-encrypt-pgpauto ())
    (defun mml-secure-encrypt-pgpmime ())
    (defun mml-secure-encrypt-smime ())

    ;; Remove new interface bad format, we only want pgpmime
    (defun mml-secure-message-sign ())
    (defun mml-secure-message-sign-encrypt ())
    (defun mml-secure-message-sign-pgp ())
    (defun mml-secure-message-sign-pgpauto ())
    (defun mml-secure-message-sign-smime ())
    (defun mml-secure-message-encrypt ())
    (defun mml-secure-message-encrypt-pgp ())
    (defun mml-secure-message-encrypt-pgpauto ())
    (defun mml-secure-message-encrypt-smime ())))
#+END_SRC

* Programming
** General
#+BEGIN_SRC emacs-lisp :comments nil
(use-package prog-mode
  :config (global-prettify-symbols-mode)
  (defun indicate-buffer-boundaries-left ()
    (setq indicate-buffer-boundaries 'left))
  (add-hook 'prog-mode-hook #'indicate-buffer-boundaries-left))

(use-package simple
  :config (column-number-mode))

(progn ;    `text-mode'
  (add-hook 'text-mode-hook #'indicate-buffer-boundaries-left))
#+END_SRC

Sometimes it's not obvious if you're at the top or bottom of a
buffer. So these indicators tell precisely that.

*** format-all: format code
#+BEGIN_SRC emacs-lisp :comments nil
(use-package format-all)
#+END_SRC

*** Flycheck
Linting
#+BEGIN_SRC emacs-lisp :comments nil
(use-package flycheck
  :hook ((prog-mode ledger-mode) . flycheck-mode)
  :bind (("<f3>" . flycheck-next-error))
  :diminish
  :config
  (global-flycheck-mode)
  (setq
    ;; Only do flycheck when I actually safe the buffer
    flycheck-check-syntax-automatically '(save mode-enable)
    ;; Keep a global mypy cache
    flycheck-python-mypy-cache-dir (expand-file-name "~/.mypy-cache")
))
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp :comments nil
(use-package lsp
  :disabled t)
;; lsp-ui shows type annotations on hover
(use-package lsp-ui
  :disabled t
  :hook ((lsp-mode-hook . lsp-ui-mode)))

;; company-lsp simplifies completion-at-point
(use-package company-lsp
  :disabled t
  :after company
  :init
    (push 'company-lsp company-backends))
#+END_SRC
** Unison
#+BEGIN_SRC emacs-lisp
;; (use-package unison-mode)
#+END_SRC
** OCaml
#+BEGIN_SRC emacs-lisp
(use-package tuareg)
#+END_SRC
** Haskell
#+BEGIN_SRC emacs-lisp :comments nil
(use-package haskell-mode
  :bind ((:map haskell-mode-map
           ("<f8>" . haskell-navigate-imports)))
  :config
  (setq haskell-stylish-on-save nil)
  (setq haskell-process-type 'stack-ghci)
  ;; Copy pasta from http://haskell.github.io/haskell-mode/manual/latest/
  (add-hook 'haskell-mode-hook
          (lambda ()
            (set (make-local-variable 'company-backends)
                 (append '((company-capf company-dabbrev-code))
                         company-backends))))
  (add-hook 'haskell-mode-hook 'haskell-auto-insert-module-template)
  (eval-after-load "haskell-mode"
    '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))
  (eval-after-load "haskell-cabal"
    '(define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile))
  (require 'haskell-interactive-mode)
  (require 'haskell-process)
  (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
  (add-hook 'inferior-haskell-mode-hook 'turn-on-comint-history)
  (define-key haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)
  (define-key haskell-mode-map (kbd "C-`") 'haskell-interactive-bring)
  (define-key haskell-mode-map (kbd "C-c C-t") 'haskell-process-do-type)
  (define-key haskell-mode-map (kbd "C-c C-i") 'haskell-process-do-info)
  (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-process-cabal-build)
  (define-key haskell-mode-map (kbd "C-c C-k") 'haskell-interactive-mode-clear)
  (define-key haskell-mode-map (kbd "C-c c") 'haskell-process-cabal))
(use-package lsp-haskell
  :disabled t
  :config
  (add-hook 'haskell-mode-hook #'lsp))
(use-package ormolu
;; :hook (haskell-mode . ormolu-format-on-save-mode)
 :bind
 (:map haskell-mode-map
   ("C-c r" . ormolu-format-buffer)))
#+END_SRC
** Dhall
#+BEGIN_SRC emacs-lisp :comments nil
(use-package dhall-mode
  :mode "\\.dhall\\'"
  :config
  (setq
    dhall-format-arguments (\` ("--ascii"))
    dhall-use-header-line nil)
)
#+END_SRC

** Purescript
#+BEGIN_SRC emacs-lisp :comments nil
(use-package purescript-mode
  :mode "\\.purs\\'"
  :config
  (add-hook 'purescript-mode-hook
    (lambda ()
      (psc-ide-mode)
      (company-mode)
      (flycheck-mode)
      (turn-on-purescript-unicode-input-method)
      (turn-on-purescript-indentation))))
(use-package psci)
#+END_SRC
** Nix
#+BEGIN_SRC emacs-lisp :comments nil
(use-package nix-mode
  :mode "\\.nix\\'")
#+END_SRC
** RPM
#+BEGIN_SRC emacs-lisp
(use-package rpm-spec-mode)
#+END_SRC

** Jinja
#+BEGIN_SRC emacs-lisp
(use-package jinja2-mode)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode)
#+END_SRC
** Bpftrace
#+BEGIN_SRC emacs-lisp
(use-package bpftrace-mode)
#+END_SRC
** Lua
#+BEGIN_SRC emacs-lisp
(use-package lua-mode)
#+END_SRC
** Yaml
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode)
#+END_SRC

** GLSL: OpenGL Shader Language
#+BEGIN_SRC emacs-lisp
(use-package glsl-mode
  :mode ("\\.vert\\'" "\\.frag\\'" "\\.glsl\\'" "\\.geom\\'"))
(use-package company-glsl
  :after glsl-mode
  :config (add-to-list 'company-backends 'company-glsl))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(use-package cython-mode
  :mode ("\\.pyd\\'" "\\.pyi\\'" "\\.pyx\\'"))
(use-package flycheck-cython
  :after (cython-mode flycheck))
(use-package flycheck-mypy
  :config
  (add-to-list 'flycheck-disabled-checkers 'python-flake8)
  (add-to-list 'flycheck-disabled-checkers 'python-pylint)
  (add-to-list 'flycheck-checkers 'python-mypy t)
)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package python
  :mode (("\\.py\\'" . python-mode))
  :interpreter ("python3" . python-mode)
  :init
  (add-hook 'inferior-python-mode-hook 'turn-on-comint-history)
  (setq
    flycheck-python-pycompile-executable "python3"
    python-shell-interpreter "python3"
    flycheck-python-pycompile-executable "python3"
    py-python-command "python3"
    ;; Don't spam message buffer when python-mode can't guess indent-offset
    python-indent-guess-indent-offset-verbose nil
))
#+END_SRC

** Lisp
#+BEGIN_SRC emacs-lisp :comments nil
(use-package elisp-mode
  :config
  (add-hook 'emacs-lisp-mode-hook (lambda ()
    (rainbow-delimiters-mode t)
    (whitespace-mode -1))))

(use-package scheme
  :config
  (setq scheme-program-name "~/.local/bin/mit-scheme"))

(use-package hy-mode
  :mode "\\.hy\\'")

;; Geiser is pretty heavy for now...
(use-package geiser
  :disabled t
  :load-path "~/.emacs.d/lib/geiser/elisp/"
  :mode "\\.scm\\'"
  :bind ("C-x C-a" . geiser-eval-definition)
  :config
  (require 'geiser-install)
  (setq
    geiser-active-implementations '(mit)
    geiser-mit-binary "~/.local/bin/mit-scheme"))
#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp :comments nil
(use-package rust-mode
  :config
  ;; Add run command

  ;; Remove unused functions
  (fmakunbound 'rust-playpen-buffer)
  (fmakunbound 'rust-playpen-region))
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp :comments nil
(use-package go-mode
  :mode "\\.go\\'"
  :hook (go-mode . go-setup))
;; Some go buffer local setup
(defun go-setup ()
  (setq tab-width 2)
  ;; Set compile command by default to 'go run ....'
  (setq-local compile-command (concat "go run " (shell-quote-argument buffer-file-name)))
  ;; gofmt on save
  (add-hook 'before-save-hook 'gofmt-before-save nil t)
  ;; stop whitespace being highlighted
  (whitespace-toggle-options '(tabs tab-mark)))
#+END_SRC
** Javascript
#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :config
  (setq-default
    js-indent-level 2
    js2-strict-missing-semi-warning nil
  )
)
(use-package rjsx-mode)
#+END_SRC

* Utility functions
Borrowed from https://github.com/abrochard/emacs-config
** Generate scratch buffer
#+BEGIN_SRC emacs-lisp
(defun generate-scratch-buffer ()
  "Create and switch to a temporary scratch buffer with a random
     name."
  (interactive)
  (switch-to-buffer (make-temp-name "scratch-")))
#+END_SRC

** Increment/decrement number at point
I miss that from Vim
#+BEGIN_SRC emacs-lisp
  (defun increment-number-at-point ()
    (interactive)
    (skip-chars-backward "0-9")
    (or (looking-at "[0-9]+")
        (error "No number at point"))
    (replace-match (number-to-string (1+ (string-to-number (match-string 0))))))

  (defun decrement-number-at-point ()
    (interactive)
    (skip-chars-backward "0-9")
    (or (looking-at "[0-9]+")
        (error "No number at point"))
    (replace-match (number-to-string (- (string-to-number (match-string 0)) 1))))

  ;;(define-key evil-normal-state-map "+" 'increment-number-at-point)
  ;;(define-key evil-normal-state-map "-" 'decrement-number-at-point)
#+END_SRC

** Move files more intuitively
#+BEGIN_SRC emacs-lisp
  (defun move-file ()
    "Write this file to a new location, and delete the old one."
    (interactive)
    (let ((old-location (buffer-file-name)))
      (call-interactively #'write-file)
      (when old-location
        (delete-file old-location))))
#+END_SRC

** Open special files quickly
#+BEGIN_SRC emacs-lisp
  (defun gtd ()
     (interactive)
     (find-file "~/org/gtd.org.gpg"))
  (defun init.org ()
    (interactive)
    (find-file "~/.emacs.d/init.org"))
#+END_SRC

* Post Initialization
#+BEGIN_SRC emacs-lisp
(message "Loading %s...done (%.3fs)" user-init-file
         (float-time (time-subtract (current-time)
                                    before-user-init-time)))
(add-hook 'after-init-hook
  (lambda ()
    (message "Loading %s...done (%.3fs) [after-init]" user-init-file
      (float-time (time-subtract (current-time) before-user-init-time)))
    ;; Restore original file name handlers
    (setq file-name-handler-alist file-name-handler-alist-old)
    ;; Let's lower our GC thresholds back down to a sane level.
    (setq gc-cons-threshold (* 20 1024 1024))
    ;; Go to home directory
    (cd (expand-file-name "~/")))
  t)
#+END_SRC

* TODOs
** TODO Fix the above inlined TODOs
** TODO Configure yassnippet and abbrev mode
** TODO Look at company-mode and enable it
** TODO Look for paren bug: (>) doesn't match properly...
